#!/bin/bash 
#
# Copyright (C) 2014, Coder of Salvation / Leon van Kammen 
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# this will hold specific curl options (when webpipes need authorisation)
declare -A CURL_OPTIONS
declare -A WEBPIPES 
TMPFILE="/tmp/.$(whoami).webpipe"

webpipe::set(){
  case "$1" in
    curloptions) CURL_OPTIONS["$2"]="$3"      ;;
    webpipe)    cmd="$(basename $2)"; WEBPIPES["$cmd"]="$2"; alias $cmd="webpipe::get $cmd";;
  esac
}

urlencode() {
  local string="${1}"; local strlen=${#string}; local encoded=""
  for (( pos=0 ; pos<strlen ; pos++ )); do
     c=${string:$pos:1}
     case "$c" in
        [-_.~a-zA-Z0-9] ) o="${c}" ;;
        * )               printf -v o '%%%02x' "'$c"
     esac
     encoded+="${o}"
  done
  echo "${encoded}"    # You can either set a return variable (FASTER) 
}

webpipe::get_domain(){
  domain="${1/http:/}"; domain="${domain/https:/}"; domain="${domain/\/\//}"; domain="${domain//\/*/}"; 
  printf "$domain"
}

webpipe::args2http(){
  httpstr="?"; pos=1; lastarg=""
  for arg in "$@"; do 
    if [[ "${arg:0:1}" == "-" ]]; then
      key="${arg//-/}"; httpstr="$httpstr&$key="; lastarg="option"
    else
      [[ "$lastarg" == "option" ]] && httpstr="$httpstr$(urlencode "$arg")" || {
        httpstr="$httpstr&$pos=$(urlencode "$arg")"; ((pos++));
      };
      lastarg="positional"
    fi
  done
  echo "${httpstr/?&/?}"
}

webpipe::get(){
  url="${WEBPIPES[$1]}";
  domain="$(webpipe::get_domain "$url")"
  # declare -A CURL_OPTIONS # bash bug? we need to do this again
  curloptions="${CURL_OPTIONS["$domain"]}"
  shift; getstr="$(webpipe::args2http "$@")"
  [[ "${#url}" == 0   ]] && return 1;
  [[ "$2" == "--help" ]] && method="-X OPTIONS" || method="-X POST"
  [[ ! -n $OUTPUT     ]] && type="text/plain" || type="$OUTPUT"
  [[ -t 0 ]] && POST="" || { cat - > $TMPFILE.post; POST="@$TMPFILE.post"; }
  [[ "${#POST}" == "0" ]] && method="-X GET"
  curl -L -s ${method} ${curloptions} -d "$POST" -H "Content-Type: $type" "$url$getstr"
  return $?
}

webpipe::index(){
  domain="$(webpipe::get_domain "$1")"
  # declare -A CURL_OPTIONS # bash bug? we need to do this again
  curloptions="${CURL_OPTIONS["$domain"]}"
  pipes="$(curl -L -s ${curloptions} "$1")"; (( $? > 0 )) && { echo "could not fetch $url"; return 1; }
  if [[ "$pipes" =~ "<" ]] || [[ "$pipes" =~ "{" ]]; then echo "$pipes"; return 1; fi 
  echo "$pipes" > $TMPFILE
  while read url; do 
    echo "webpipe> adding $url"
    webpipe::set webpipe "$url"
  done < $TMPFILE
}

webpipe::list(){
  for webpipe in "${WEBPIPES[@]}"; do echo "$webpipe"; done
}

