{"name":"Webpipe.bash","tagline":"extend your bash using webpipes, aka bash-in-the-cloud","body":"Webpipe.bash \r\n============\r\n\r\nWebpipes empower your bash-environment with remote executed applications, aka Bash in the Cloud.\r\n\r\n### Why\r\n\r\nExpose your webapplication as unix commands.\r\nWrite less html-interfaces, write more glue.\r\nMashup your webpipes, mashup your api.\r\n\r\n<center><img alt=\"\" src=\"http://media1.giphy.com/media/MVlRUmPRsAnRe/200.gif\"/></center>\r\n\r\n### Installation\r\n\r\nIts very simple, first get webpipe.bash\r\n\r\n    wget https://raw.github.com/coderofsalvation/webpipe.bash/master/webpipe\r\n\r\nNow the only thing you need to do is index some online webpipes:\r\n\r\n    source webpipe\r\n    webpipe::index http://neon-semiotics-490.appspot.com\r\n\r\nDone! Now you can just use a webpipe in your terminal as if it were a local unix command.\r\n\r\n\r\n### Example of a webpipe\r\n\r\nShow usage:\r\n\r\n    $ xpath\r\n    Usage: echo <xmltext> | xpath <xpath> [options]\r\n    \r\n    prints values from xml based on given xpath (can be commaseperated)\r\n    \r\n    Options:\r\n         --dumppath          dump xpath instead of values \r\n         --dumppathvalues    dump xpath with values \r\n         --manual            show examples/syntax\r\n         --html              input is html instead of xml\r\n         --source            dont strip tags \r\n    \r\n    Examples:\r\n      echo '<xml><foo><bar>123</bar></foo></xml>' | xpath //foo/bar\r\n      echo '<xml><foo><bar>123</bar></foo></xml>' | xpath //* --dumppath\r\n      echo '<xml><foo><bar>123</bar></foo></xml>' | xpath //* --dumppathvalues\r\n\r\nExecute it:\r\n\r\n    $ cat foo.xml | xpath //order/customer/name\r\n    John Doe\r\n\r\nWould you believe this just happened in the cloud?\r\nWell it did..\r\n\r\n### How it works\r\n\r\n<img alt=\"\" src=\"https://raw.github.com/coderofsalvation/webpipe.bash/master/doc/webpipe.png\"/>\r\n\r\n### Indexing a single webpipe\r\n\r\nYou can also import a batch of webpipes all at once like this:\r\n\r\n    source webpipe\r\n    webpipe::set webpipe http://localhost/mypipe\r\n\r\nVoila..now mypipe is indexed..\r\n\r\n### Always anywhere\r\n\r\nPut this in your .bashrc :\r\n\r\n    source ~/bin/webpipe \r\n    webpipe::indexcache                   # this loads webpipes from cache (faster)\r\n\r\n### Show webpipes\r\n\r\n    $ webpipe::list\r\n    mypipe         -> http://localhost/mypipe\r\n    xpath          -> http://neon-semiotics-490.appspot.com/xpath\r\n    cssselect      -> http://neon-semiotics-490.appspot.com/cssselect\r\n    csv2json       -> http://neon-semiotics-490.appspot.com/csv2json\r\n    json2csv       -> http://neon-semiotics-490.appspot.com/json2csv\r\n    json_print_r   -> http://neon-semiotics-490.appspot.com/json_print_r\r\n    jsonpath       -> http://neon-semiotics-490.appspot.com/jsonpath\r\n    markdown       -> http://neon-semiotics-490.appspot.com/markdown\r\n    striphtml      -> http://neon-semiotics-490.appspot.com/striphtml\r\n    url2html       -> http://neon-semiotics-490.appspot.com/url2html\r\n    xml2json       -> http://neon-semiotics-490.appspot.com/xml2json\r\n    mycommand      -> http://foo.bar.com/mycommand\r\n    sendmail       -> http://foo.bar.com/sendmail\r\n    notifypentagon -> http://foo.bar.com/notifypentagon\r\n    makecoffee     -> http://foo.bar.com/makecoffee\r\n    notifypentagon -> http://foo.bar.com/notifypentagon\r\n\r\n### Reset \r\n\r\nReset all your indexed webpipes\r\n\r\n    webpipe::reset\r\n\r\n### How can I build my own webpipes in the cloud?\r\n\r\nSimple, a webpipe is just a weburl which listens to a POST-request (for data) or OPTIONS-request (for displaying help).\r\n\r\nBasically all GET-, POST- etc arguments are combined into one object, which processed by the webpipe.\r\nThe webpipe returns output which suits the content-type.\r\nSo with 'application/json':\r\n\r\n    {\"output\":[\"foo\",\"bar\"]}\r\n\r\nCould be with 'text/plain' (a unix webpipe)\r\n\r\n    foo\r\n    bar\r\n\r\nFor php there's this skeleton [repository](https://github.com/coderofsalvation/webpipe.bash.php).\r\n\r\n### But I'm in love with JSON/\r\n\r\nThe commandline is great, but yes, at some point JSON becomes preferrable (to avoid complex oneliners).\r\nLets take the xpath example above, imagine we have 10 other arguments.\r\nIn that case it might be handy to hide our complexity in a json payload file:\r\n\r\n      $ cat > payload.json\r\n      {\r\n        \"path\": \"//order/customer/name\"\r\n        \"input\": \"$pipe\"\r\n      }\r\n      (CTRL-D)\r\n\r\n      $ cat foo.xml | xpath payload.json \r\n      John Doe\r\n\r\nWhenever the first argument is a jsonfile, Webpipe.bash will do a POST-request with content-type 'application/json'.\r\n\r\n### Capture/Replay\r\n\r\nYou can inspect your payload anywhere in the pipeline.\r\n\r\n    $ cat foo.xml | CAPTURE=1 log --job | filter --inactive --retired | CAPTURE=1 xpath payload.json \r\n    written 'log.payload.10928391.json'\r\n    written 'xpath.payload.10928392.json'\r\n\r\nAnd replay it (usefull for testing/debugging):\r\n\r\n    $ log log.payload.10928391.json\r\n    $ xpath xpath.payload.10928391.json\r\n\r\n### RESTful?\r\n\r\n    $ cat foo.xml | X=DELETE TYPE=\"application/soap+xml\" somewebpipe payload.json\r\n\r\nHowever, this is not really the focus of webpipes, see [RESTY](https://github.com/micha/resty) for easily testing REST api's and such.\r\n\r\n### Basic design of UNIX webpipe\r\n\r\nWebpipes usually work with 'application/json' which is fine.\r\nBut unix output (tab-delimited e.g.) can be implemented by listening to content-type 'text/plain':\r\n    \r\n    $ mywebpipe foobar --foo bar\r\n\r\nwould result in a 'text/plain' GET-request:\r\n\r\n<img alt=\"\" src=\"https://raw.github.com/coderofsalvation/webpipe.bash/master/doc/unixwebpipe-get.png\"/>\r\n\r\n    $ cat foo.json | webpipe --foo bar \r\n\r\nwould result in a 'text/plain' POST-request:    \r\n\r\n<img alt=\"\" src=\"https://raw.github.com/coderofsalvation/webpipe.bash/master/doc/unixwebpipe-post.png\"/>\r\n\r\n    $ mywebpipe\r\n    Usage: mywebpipe <arg> [-foo <str>]\r\n \r\nThis would result in an 'text/plain' OPTIONS-request (which should return information on usage)\r\n\r\n\r\n### Projects using webpipe.bash \r\n\r\n* www.bashlive.com ( supernatural livecoding using bash )\r\n\r\n### Security\r\n\r\nSourcing output of remote procedures from untrusted sources is never adviced.\r\nHowever, in case your webpipes needs authorisation (.htaccess .htpasswd e.g.) run, decorate the curl calls with this:\r\n\r\n    webpipe::set curloptions http://foo.com \"-user foo:bar\"\r\n\r\nBy doing so, the webpipe (called by curl) will pass authorisation info.\r\n\r\n# Compatibility with WebPipe Specification 0.2\r\n\r\nThe webpipes above are more or less compatible.\r\nOne exception is that requests (with content-type 'plain/text',  used in the example above) uses single-input single-output.\r\nThis is to easify unix commandline development, in contrast to the multi-jsoninput multi-jsonoutput requirement of the <a target=\"_blank\" href=\"http://www.webpipes.org/\" ></a>webpipe 0.2</a>.\r\n`(Jeff: if you read this, please contact me)`\r\nHowever, the multi-jsoninput multi-jsonoutput requirement *should* apply when you call it with content-type 'application/json'.\r\n\r\nSome examples:\r\n\r\n    $ curl -X POST    -H 'Content-Type: text/plain' http://localhost/foobar\r\n    # should return the processed value (\"some value for bar\" e.g.)\r\n\r\n    $ curl -X POST    -H 'Content-Type: application/json' -d '{\"inputs\":[{\"css\":\".foo { font-weight:bold; }\"}]}' http://localhost/foobar\r\n    # should return: {\"outputs\": [{\"bar\": \"some value for bar\"}]}\r\n    \r\n    $ curl -X OPTIONS -H 'Content-Type: text/plain' http://localhost/foobar\r\n    # should return usage text like 'Usage: foo <dir> <file>' e.g. (see top of this page)\r\n\r\n    $ curl -X OPTIONS -H 'Content-Type: application/json' http://localhost/foobar\r\n    # should return a json schema like so:\r\n    # {\r\n    #     name: String\r\n    #     url: String\r\n    #     description: String\r\n    #     inputs: {\r\n    #         name: String\r\n    #         type: String (Array, String, Number, Boolean)\r\n    #         description: String\r\n    #         optional?: Boolean\r\n    #         default?: Any\r\n    #     }\r\n    #     outputs: {\r\n    #         name: String\r\n    #         type: String (Array, String, Number, Boolean)\r\n    #         description: String\r\n    #     }\r\n    # }\r\n\r\n    $ curl -X TRACE http://localhost/foobar \r\n    # debugs / runs unit test(s) e.g.\r\n\r\nHowever, this multi-in multi-out-assumption of the specs doesnt really fit my needs, therefore for practical reasons contenttypes 'text/plain' and 'text/html' default to single-textinput single-textoutput..the default behaviour of any webserver.\r\n\r\n### Commandline argument to getarguments\r\n\r\nBy default webpipe.bash will send http using the 'text/plain'-content-type.\r\nPositional parameters will be converted to GET variable '1' / '2' and so on, like so:\r\n\r\n    mywebpipe somevar --foo bar --foo2 bar2\r\n\r\nIn the webpipe itself this will be received as GET variables:\r\n\r\n    '1': 'somevar',\r\n    'foo': 'bar',\r\n    'foo2': 'bar2'\r\n\r\nThis makes it easy to start developing a webpipe by using webpipe.bash as a startingpoint:\r\n\r\n    $ webpipe::set webpipe http://localhost/mynewwebpipe\r\n    $ mynewwebpipe hellowrodl --foo bar \r\n    <html>\r\n      404 Not found\r\n      method:   GET\r\n      Get args: '1'   => hellowrodl\r\n                'foo' => bar\r\n    </html>\r\n\r\n    $ echo \"fooo\" | mynewwebpipe hellowrodl --foo bar \r\n    <html>\r\n      404 Not found\r\n      method:   POST\r\n      Get args: '1'   => hellowrodl\r\n                'foo' => bar\r\n      Post payload: 'foooo'                \r\n    </html>\r\n\r\n### Further Thoughts\r\n\r\n* webpipe is easy to scale\r\n* install once, usable anywhere\r\n* centralize certain functionality on certain server\r\n* prevent a developer becoming 'the guy' within a team\r\n* teams dont need graphical user interfaces\r\n* teams need something pipable\r\n* prevents a large codebase \r\n* spread domainknowledge across webpipes instead of bundling in 1 codebase\r\n* bash can be an interface between programmers with different backgrounds\r\n* unix pipelining is a service bus in certain perspective\r\n* webpipes need tests\r\n* webpipes need to notify a central place in case of problems .e.g\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}