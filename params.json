{"name":"Webpipe.bash","tagline":"extend your bash using webpipes, aka bash-in-the-cloud","body":"Write less html-interfaces, write more glue.\r\nMashup your webpipes, mashup your api.\r\n\r\n<center><img alt=\"\" src=\"http://media1.giphy.com/media/MVlRUmPRsAnRe/200.gif\"/></center>\r\n\r\n### Installation\r\n\r\nIts very simple, first get webpipe.bash\r\n\r\n    wget https://raw.github.com/coderofsalvation/webpipe.bash/master/webpipe\r\n\r\nNow the only thing you need to do is index some online webpipes:\r\n\r\n    source webpipe\r\n    webpipe::index http://neon-semiotics-490.appspot.com\r\n\r\nDone! Now you can just use a webpipe in your terminal as if it were a local unix command.\r\n\r\n\r\n### Example of a webpipe\r\n\r\nShow usage:\r\n\r\n    $ xpath\r\n    Usage: echo <xmltext> | xpath <xpath> [options]\r\n    \r\n    prints values from xml based on given xpath (can be commaseperated)\r\n    \r\n    Options:\r\n         --dumppath          dump xpath instead of values \r\n         --dumppathvalues    dump xpath with values \r\n         --manual            show examples/syntax\r\n         --html              input is html instead of xml\r\n         --source            dont strip tags \r\n    \r\n    Examples:\r\n      echo '<xml><foo><bar>123</bar></foo></xml>' | xpath //foo/bar\r\n      echo '<xml><foo><bar>123</bar></foo></xml>' | xpath //* --dumppath\r\n      echo '<xml><foo><bar>123</bar></foo></xml>' | xpath //* --dumppathvalues\r\n\r\nExecute it:\r\n\r\n    $ cat foo.xml | xpath //order/customer/name\r\n    John Doe\r\n\r\nWould you believe this just happened in the cloud?\r\nWell it did..\r\n\r\n### How it works\r\n\r\n<img alt=\"\" src=\"https://raw.github.com/coderofsalvation/webpipe.bash/master/webpipe.png\"/>\r\n\r\n### Indexing a single webpipe\r\n\r\nYou can also import a batch of webpipes all at once like this:\r\n\r\n    source webpipe\r\n    webpipe::set webpipe http://localhost/mypipe\r\n\r\nVoila..now mypipe is indexed..\r\n\r\n`HINT: you can put the above in your ~/.bashrc`\r\n\r\n### Show webpipes\r\n\r\n    $ webpipe::list\r\n    http://localhost/mypipe\r\n    http://neon-semiotics-490.appspot.com/xpath\r\n    http://neon-semiotics-490.appspot.com/cssselect\r\n    http://neon-semiotics-490.appspot.com/csv2json\r\n    http://neon-semiotics-490.appspot.com/json2csv\r\n    http://neon-semiotics-490.appspot.com/json_print_r\r\n    http://neon-semiotics-490.appspot.com/jsonpath\r\n    http://neon-semiotics-490.appspot.com/markdown\r\n    http://neon-semiotics-490.appspot.com/striphtml\r\n    http://neon-semiotics-490.appspot.com/url2html\r\n    http://neon-semiotics-490.appspot.com/xml2json\r\n    http://foo.bar.com/mycommand\r\n    http://foo.bar.com/sendmail\r\n    http://foo.bar.com/notifypentagon\r\n    http://foo.bar.com/makecoffee\r\n    http://foo.bar.com/notifypentagon\r\n\r\n### How can I build my own webpipes in the cloud?\r\n\r\nSimple, a webpipe is just a weburl which listens to a POST-request (for data) or OPTIONS-request (for displaying help).\r\n\r\nFor php there's this skeleton [repository](https://github.com/coderofsalvation/webpipe.bash.php)\r\n\r\n### Projects using webpipe.bash \r\n\r\n* bashlive.com ( supernatural livecoding using bash )\r\n\r\n### Security\r\n\r\nSourcing output of remote procedures from untrusted sources is never adviced.\r\nHowever, in case your webpipes needs authorisation (.htaccess .htpasswd e.g.) run, decorate the curl calls with this:\r\n\r\n    webpipe::set curloptions http://foo.com \"-user foo:bar\"\r\n\r\nBy doing so, the webpipe (called by curl) will pass authorisation info.\r\n\r\n# Compatibility with WebPipe Specification 0.2\r\n\r\nThe webpipes above are more or less compatible.\r\nOne exception is that requests (with content-type 'plain/text',  used in the example above) uses single-input single-output.\r\nThis is to easify unix commandline development, in contrast to the multi-jsoninput multi-jsonoutput requirement of the <a target=\"_blank\" href=\"http://www.webpipes.org/\" ></a>webpipe 0.2</a>.\r\n`(Jeff: if you read this, please contact me)`\r\nHowever, the multi-jsoninput multi-jsonoutput requirement *should* apply when you call it with content-type 'application/json'.\r\n\r\nSome examples:\r\n\r\n    $ curl -X POST    -H 'Content-Type: text/plain' http://localhost/foobar\r\n    # should return the processed value (\"some value for bar\" e.g.)\r\n\r\n    $ curl -X POST    -H 'Content-Type: application/json' -d '{\"inputs\":[{\"css\":\".foo { font-weight:bold; }\"}]}' http://localhost/foobar\r\n    # should return: {\"outputs\": [{\"bar\": \"some value for bar\"}]}\r\n    \r\n    $ curl -X OPTIONS -H 'Content-Type: text/plain' http://localhost/foobar\r\n    # should return usage text like 'Usage: foo <dir> <file>' e.g. (see top of this page)\r\n\r\n    $ curl -X OPTIONS -H 'Content-Type: application/json' http://localhost/foobar\r\n    # should return a json schema like so:\r\n    # {\r\n    #     name: String\r\n    #     url: String\r\n    #     description: String\r\n    #     inputs: {\r\n    #         name: String\r\n    #         type: String (Array, String, Number, Boolean)\r\n    #         description: String\r\n    #         optional?: Boolean\r\n    #         default?: Any\r\n    #     }\r\n    #     outputs: {\r\n    #         name: String\r\n    #         type: String (Array, String, Number, Boolean)\r\n    #         description: String\r\n    #     }\r\n    # }\r\n\r\n    $ curl -X TRACE http://localhost/foobar \r\n    # debugs / runs unit test(s) e.g.\r\n\r\nHowever, this multi-in multi-out-assumption of the specs doesnt really fit my needs, therefore for practical reasons contenttypes 'text/plain' and 'text/html' default to single-textinput single-textoutput..the default behaviour of any webserver.\r\n\r\n### Further Thoughts\r\n\r\n* webpipe is easy to scale\r\n* install once, usable anywhere\r\n* centralize certain functionality on certain server\r\n* prevent a developer becoming 'the guy' within a team\r\n* teams dont need graphical user interfaces\r\n* teams need something pipable\r\n* prevents a large codebase \r\n* spread domainknowledge across webpipes instead of bundling in 1 codebase\r\n* webpipes need tests\r\n* webpipes need to notify a central place in case of problems .e.g\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}